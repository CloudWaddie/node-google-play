/**
 * @file Defines JavaScript classes for device properties, integrating Protocol Buffer decoding.
 * Corresponds to the Rust `EncodedDeviceProperties` and `DeviceProperties` structs.
 * Requires the generated Protocol Buffer classes from your .proto files.
 */

// --- Import Generated Protocol Buffer Classes ---
// IMPORTANT: Make sure the path below is correct relative to this file.
// The names of the imported classes (DeviceConfigurationProto, AndroidCheckinProto)
// must match the message names defined in your .proto files and generated by protobufjs.
// You will need to run protobufjs to generate 'google_play_protos.js' based on your .proto files.
const { DeviceConfigurationProto, AndroidCheckinProto } = require('./protos/GooglePlay.js');

// --- EncodedDeviceProperties Class ---
/**
 * Corresponds to the Rust `EncodedDeviceProperties` struct.
 * Holds the raw, encoded byte data and extra info, typically before decoding.
 * Designed for serialization/deserialization of the raw form.
 */
class EncodedDeviceProperties {
  /**
   * Constructor for EncodedDeviceProperties.
   * @param {Buffer|Uint8Array|Array<number>} device_configuration - Raw bytes of the device configuration. Will be converted to Buffer.
   * @param {Buffer|Uint8Array|Array<number>} android_checkin - Raw bytes of the Android check-in data. Will be converted to Buffer.
   * @param {Record<string, string>} extra_info - Additional string key-value pairs. Corresponds to Rust's HashMap<String, String>.
   */
  constructor(device_configuration, android_checkin, extra_info) {
    // Ensure inputs are Buffers. Buffer.from() handles various input types like Arrays, Uint8Arrays, or existing Buffers.
    this.device_configuration = Buffer.from(device_configuration);
    this.android_checkin = Buffer.from(android_checkin);
    this.extra_info = extra_info;
  }

  /**
   * Corresponds to the Rust `to_decoded` method.
   * Decodes the raw byte data stored in this instance into structured objects
   * using the generated Protocol Buffer classes.
   * @returns {DeviceProperties} An instance of DeviceProperties containing the decoded data.
   * @throws {Error} If decoding of either device_configuration or android_checkin fails.
   */
  toDecoded() {
    let decodedDeviceConfig;
    let decodedAndroidCheckin;

    // Decode device_configuration using the generated Protobuf class
    try {
      // DeviceConfigurationProto.decode expects a Buffer or Uint8Array
      decodedDeviceConfig = DeviceConfigurationProto.decode(this.device_configuration);
    } catch (error) {
      console.error("Error decoding DeviceConfigurationProto:", error);
      // Throw a specific error to indicate which part failed
      throw new Error(`Failed to decode device configuration: ${error.message}`);
    }

    // Decode android_checkin using the generated Protobuf class
    try {
      // AndroidCheckinProto.decode expects a Buffer or Uint8Array
      decodedAndroidCheckin = AndroidCheckinProto.decode(this.android_checkin);
    } catch (error) {
      console.error("Error decoding AndroidCheckinProto:", error);
      // Throw a specific error to indicate which part failed
      throw new Error(`Failed to decode Android check-in: ${error.message}`);
    }

    // Return a new instance of the decoded DeviceProperties class
    return new DeviceProperties(
      decodedDeviceConfig,
      decodedAndroidCheckin,
      this.extra_info
    );
  }

  // Optional: Method to create an EncodedDeviceProperties instance from a decoded one.
  // This would require encoding the Protobuf objects back to bytes.
  // static fromDecoded(deviceProperties) {
  //   // This depends on how your Protobuf messages are structured and if you have
  //   // corresponding encode methods or wrapper messages.
  //   // Example (requires encode methods on Proto classes):
  //   // const encodedDeviceConfig = DeviceConfigurationProto.encode(deviceProperties.device_configuration).finish();
  //   // const encodedAndroidCheckin = AndroidCheckinProto.encode(deviceProperties.android_checkin).finish();
  //   // return new EncodedDeviceProperties(encodedDeviceConfig, encodedAndroidCheckin, deviceProperties.extra_info);
  // }
}

// --- DeviceProperties Class ---
/**
 * Corresponds to the Rust `DeviceProperties` struct.
 * Holds the decoded, structured data and extra info, ready for use in application logic.
 */
class DeviceProperties {
  /**
   * Constructor for DeviceProperties.
   * @param {object} device_configuration - Decoded device configuration object (an instance created by DeviceConfigurationProto.decode).
   * @param {object} android_checkin - Decoded Android check-in object (an instance created by AndroidCheckinProto.decode).
   * @param {Record<string, string>} extra_info - Additional string key-value pairs.
   */
  constructor(device_configuration, android_checkin, extra_info) {
    this.device_configuration = device_configuration;
    this.android_checkin = android_checkin;
    this.extra_info = extra_info;
  }

  // Add any methods needed for working with the decoded properties here.
  // For example, methods to access specific fields from device_configuration or android_checkin
  // in a user-friendly way.
}

// --- Exporting the classes ---
// Export the classes so they can be imported and used in other parts of your Node.js project.
module.exports = {
  EncodedDeviceProperties,
  DeviceProperties,
  // You might also choose to export the Protobuf classes themselves if they are
  // frequently needed elsewhere, though importing them directly where used is common.
  // DeviceConfigurationProto,
  // AndroidCheckinProto,
};
